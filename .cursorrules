# Modern C++ Project - Cursor Rules & Best Practices

This document defines the coding standards, best practices, and conventions used in this modern C++ project. Follow these guidelines when working with AI assistance in Cursor.

---

## Project Overview

This is a **Modern C++ Template** project that follows industry best practices for:
- CMake-based build system
- C++17 standard compliance
- Modular architecture with clear separation of concerns
- Comprehensive testing with GoogleTest
- Code quality tools (clang-format, clang-tidy, cppcheck)
- CI/CD integration
- Documentation with Doxygen

The project includes a **Virtual Switch Network** implementation demonstrating:
- TAP device management (Layer 2 networking)
- Virtual port (VPort) implementation in C
- Python-based virtual switch with MAC learning
- UDP-based frame forwarding
- Multi-threaded architecture

---

## Build System - CMake Best Practices

### Project Structure
```
project/
├── CMakeLists.txt           # Main build configuration
├── cmake/                   # CMake modules
│   ├── StandardSettings.cmake
│   ├── CompilerWarnings.cmake
│   ├── SourcesAndHeaders.cmake
│   ├── StaticAnalyzers.cmake
│   ├── Utils.cmake
│   └── ...
├── include/                 # Public headers
│   └── project/            # Namespace folder
├── src/                    # Implementation files
├── test/                   # Unit tests
│   ├── CMakeLists.txt
│   └── src/
└── docs/                   # Documentation
```

### CMake Conventions

1. **Minimum Version**: Always use CMake 3.15+
   ```cmake
   cmake_minimum_required(VERSION 3.15)
   ```

2. **Project Declaration**: Use explicit versioning and language specification
   ```cmake
   project(
     "ProjectName"
     VERSION 0.1.0
     LANGUAGES CXX
   )
   ```

3. **Prevent In-Source Builds**: Always enforce out-of-source builds
   ```cmake
   if(PROJECT_SOURCE_DIR STREQUAL PROJECT_BINARY_DIR)
     message(FATAL_ERROR "In-source builds not allowed. Please make a new directory (called a build directory) and run CMake from there.\n")
   endif()
   ```

4. **Use Modern Target-Based CMake**:
   - Use `target_include_directories()` not `include_directories()`
   - Use `target_link_libraries()` with `PUBLIC`/`PRIVATE`/`INTERFACE` keywords
   - Use `target_compile_features()` for C++ standard requirements

5. **Export Compile Commands**: Always enable for IDE integration
   ```cmake
   set(CMAKE_EXPORT_COMPILE_COMMANDS ON)
   ```

6. **Build Modes**: Support different build configurations
   - Default to "Debug" if not specified
   - Use appropriate compiler flags per configuration

### CMake Options Pattern

Define project options with namespacing:
```cmake
option(${PROJECT_NAME}_BUILD_EXECUTABLE "Build as executable" OFF)
option(${PROJECT_NAME}_ENABLE_UNIT_TESTING "Enable unit tests" ON)
option(${PROJECT_NAME}_ENABLE_CLANG_TIDY "Enable static analysis" OFF)
option(${PROJECT_NAME}_ENABLE_CODE_COVERAGE "Enable coverage" OFF)
option(${PROJECT_NAME}_ENABLE_DOXYGEN "Enable documentation" OFF)
option(${PROJECT_NAME}_ENABLE_CCACHE "Enable ccache" ON)
option(${PROJECT_NAME}_ENABLE_ASAN "Enable Address Sanitizer" OFF)
```

---

## Code Structure & Organization

### Header Files

1. **Header Guards**: Use `#ifndef` guards with unique names
   ```cpp
   #ifndef PROJECT_MODULE_H_
   #define PROJECT_MODULE_H_
   
   // content
   
   #endif  // PROJECT_MODULE_H_
   ```

2. **Namespace Usage**: Always wrap code in project namespace
   ```cpp
   namespace project_name
   {
     // your code
   }
   ```

3. **Include Order**:
   1. Related header (for .cpp files)
   2. C system headers
   3. C++ standard library headers
   4. Third-party library headers
   5. Project headers

4. **Forward Declarations**: Use when possible to reduce compile times

### Source Files

1. **One Class Per File**: Each class should have its own `.hpp` and `.cpp` files
2. **Implementation Details**: Keep private implementation in source files
3. **Minimal Headers**: Include only what you use

### Directory Structure Rules

- `include/project/`: Public API headers only
- `src/`: Implementation files and private headers
- `test/src/`: Test files matching source files (e.g., `tmp_test.cpp` for `tmp.cpp`)
- `cmake/`: All CMake modules and utilities
- `docs/`: Documentation (architecture, diagrams, API docs)
- `reference/`: Reference implementations or external code

---

## C++ Standards & Best Practices

### Language Standard

- **Use C++17** as the baseline standard
- Enable via: `target_compile_features(target PUBLIC cxx_std_17)`
- Follow [C++ Core Guidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines)

### Coding Style (clang-format)

This project uses a **Google-based style** with modifications:

```yaml
BasedOnStyle: Google
BreakBeforeBraces: Allman
ColumnLimit: 125
NamespaceIndentation: All
AllowShortFunctionsOnASingleLine: None
AllowShortIfStatementsOnASingleLine: Never
AllowShortLoopsOnASingleLine: false
AlignConsecutiveMacros: true
```

**Key Points**:
- **Allman brace style**: Braces on new lines
- **125 character line limit**
- **Indent namespace contents**
- **No single-line functions, ifs, or loops**
- **Break after open brackets** for long parameter lists

### Modern C++ Practices

1. **Use `auto` appropriately**: When type is obvious or verbose
   ```cpp
   auto it = container.begin();  // Good
   auto value = static_cast<int>(something);  // Bad - type not obvious
   ```

2. **Prefer `nullptr` over `NULL` or `0`**

3. **Use smart pointers** over raw pointers for ownership
   - `std::unique_ptr<T>` for exclusive ownership
   - `std::shared_ptr<T>` for shared ownership
   - Raw pointers only for non-owning references

4. **Use range-based for loops**:
   ```cpp
   for (const auto& item : collection)
   {
     // process item
   }
   ```

5. **Prefer `constexpr` over `#define` for constants**

6. **Use `[[nodiscard]]` for functions that return values that shouldn't be ignored**

7. **Use `override` and `final` keywords** for virtual functions

8. **Initialize members in the declaration** when possible:
   ```cpp
   class MyClass
   {
   private:
     int value_ = 0;
     std::string name_ = "default";
   };
   ```

### Error Handling

1. **Prefer exceptions** for error handling (don't use error codes for recoverable errors)
2. **Use assertions** for programming errors:
   ```cpp
   #include <cassert>
   assert(pointer != nullptr && "Pointer must not be null");
   ```
3. **For C code** (like VPort implementation): Use error codes and macros:
   ```c
   #define ERROR_PRINT_THEN_EXIT(msg...) \
     fprintf(stderr, ##msg);             \
     exit(1);
   ```

### Naming Conventions

1. **Classes/Structs**: PascalCase
   - `VirtualSwitch`, `PacketHandler`

2. **Functions/Methods**: snake_case or camelCase (be consistent)
   - `calculate_total()` or `calculateTotal()`
   - This project uses: `add()`, `process_frame()`

3. **Variables**: snake_case
   - `frame_buffer`, `mac_address`

4. **Constants**: UPPER_SNAKE_CASE or k prefix
   - `MAX_FRAME_SIZE` or `kMaxFrameSize`

5. **Private Members**: trailing underscore
   - `value_`, `internal_state_`

6. **Namespaces**: lowercase, short
   - `tmp`, `network`, `utils`

---

## Compiler Warnings & Static Analysis

### Compiler Warnings

**Enable comprehensive warnings** through `CompilerWarnings.cmake`:

**GCC/Clang**:
```cmake
-Wall -Wextra -Wshadow -Wnon-virtual-dtor -Wold-style-cast
-Wcast-align -Wunused -Woverloaded-virtual -Wpedantic
-Wconversion -Wsign-conversion -Wnull-dereference
-Wdouble-promotion -Wformat=2
```

**MSVC**:
```cmake
/W4 /permissive-
```

**Treat warnings as errors** option available:
```cmake
option(${PROJECT_NAME}_WARNINGS_AS_ERRORS "Treat warnings as errors" OFF)
```

### Static Analyzers

1. **Clang-Tidy**: Primary static analyzer
   ```bash
   cmake -B build -DProject_ENABLE_CLANG_TIDY=1
   ```

2. **Cppcheck**: Additional checks
   ```bash
   cmake -B build -DProject_ENABLE_CPPCHECK=1
   ```

### Code Formatting

**Always run clang-format** before committing:
```bash
# Via CMake target
cmake --build build --target clang-format

# Or via Makefile
make format

# Or manually
clang-format -i include/project/*.hpp src/*.cpp
```

---

## Testing Practices

### Unit Testing with GoogleTest

1. **Test File Naming**: `<source_file>_test.cpp`
   - `tmp.cpp` → `tmp_test.cpp`

2. **Test Structure**:
   ```cpp
   #include "project/module.hpp"
   #include <gtest/gtest.h>
   
   TEST(TestSuiteName, TestName)
   {
     // Arrange
     int expected = 3;
     
     // Act
     int result = module::add(1, 2);
     
     // Assert
     ASSERT_EQ(result, expected);
   }
   
   int main(int argc, char **argv)
   {
     ::testing::InitGoogleTest(&argc, argv);
     return RUN_ALL_TESTS();
   }
   ```

3. **Test Naming Convention**:
   - Suite: `ModuleNameOperationTest`
   - Test: `CheckSpecificBehavior`
   - Example: `TEST(TmpAddTest, CheckValues)`

4. **Assertions**:
   - `ASSERT_*`: Fatal - stops test execution
   - `EXPECT_*`: Non-fatal - continues test execution
   - Use `EXPECT_*` when possible

5. **Include tests** for:
   - Normal cases
   - Edge cases
   - Error conditions
   - Boundary values

### Running Tests

```bash
# Build with tests enabled
cmake -B build -DProject_ENABLE_UNIT_TESTING=1

# Run tests
cd build && ctest -C Release -VV

# Or via Makefile
make test

# Code coverage
make coverage
```

### Test Organization

- Each test file should test **one module**
- Group related tests in **test suites**
- Use **test fixtures** for shared setup/teardown
- Keep tests **independent** and **deterministic**

---

## Documentation

### Code Documentation

1. **Use Doxygen-style comments** for public APIs:
   ```cpp
   /**
    * @brief Adds two integers
    * 
    * @param a First integer
    * @param b Second integer
    * @return Sum of a and b
    */
   int add(int a, int b);
   ```

2. **Document**:
   - All public functions
   - All classes and structs
   - Complex algorithms
   - Non-obvious code sections
   - Thread safety requirements

3. **Inline comments**: Explain *why*, not *what*
   ```cpp
   // Good: Explains reasoning
   // Use Allman braces for consistency with project style
   
   // Bad: Explains obvious
   // Increment i by 1
   i++;
   ```

### Architecture Documentation

This project uses **Mermaid diagrams** for visual documentation:

1. **System Architecture**: Component relationships
2. **Sequence Diagrams**: Interaction flows
3. **State Machines**: State transitions
4. **Class Diagrams**: Object-oriented design

Example locations:
- `docs/architecture-overview.md`
- `docs/sequence-diagram.md`
- `docs/class-diagram.md`

### Generating Documentation

```bash
# Enable Doxygen
cmake -B build -DProject_ENABLE_DOXYGEN=1
cmake --build build --target doxygen-docs

# Or via Makefile
make docs
```

---

## Development Workflow

### Git Workflow

1. **Never commit directly to `master`/`main`**
2. **Use feature branches**: `feature/description` or `fix/issue-number`
3. **Clean commit history**: Use `git rebase` to organize commits
4. **Commit messages**: Follow conventional commits
   ```
   type(scope): subject
   
   body (optional)
   
   footer (optional)
   ```

### CI/CD Integration

This project uses **GitHub Actions** for:
- **Multi-platform builds**: Windows, Linux, macOS
- **Automated testing**: Run on every commit
- **Code coverage**: Integration with Codecov
- **Static analysis**: Clang-tidy checks

**Skip CI** when needed:
```bash
git commit -m "docs: update README [skip ci]"
# or
git commit -m "docs: update README [ci skip]"
```

### Code Review Checklist

Before submitting PR:
- [ ] Code follows project style (run clang-format)
- [ ] All tests pass locally
- [ ] New tests added for new functionality
- [ ] Documentation updated (code comments + docs/)
- [ ] No compiler warnings
- [ ] Static analyzers pass (if enabled)
- [ ] Commit messages are clear and descriptive

---

## Virtual Switch Network - Project Specific

### Architecture Overview

This project implements a **learning switch** with:

1. **VPort (C)**: Virtual port with TAP device
   - Creates TAP interface (`tapyuan`)
   - Two threads: up-forwarder and down-forwarder
   - Communicates via UDP with VSwitch

2. **VSwitch (Python)**: Central switching fabric
   - MAC address learning
   - Frame forwarding logic
   - Handles broadcast frames

3. **TAP Devices**: Layer 2 virtual network interfaces
   - Created with `IFF_TAP | IFF_NO_PI` flags
   - Operate at Ethernet frame level

### Networking Concepts Used

1. **Layer 2 (Data Link)**:
   - Ethernet frames (14-byte header: dst MAC, src MAC, type)
   - MAC address learning and forwarding
   - Broadcast handling (`ff:ff:ff:ff:ff:ff`)

2. **TAP vs TUN**:
   - **TAP**: Layer 2 (Ethernet frames) - Used in this project
   - **TUN**: Layer 3 (IP packets)

3. **UDP Communication**:
   - Connectionless, low latency
   - VPort ↔ VSwitch communication
   - Encapsulates Ethernet frames

### Threading Model

**VPort uses pthread**:
```c
pthread_t up_thread;   // TAP → VSwitch
pthread_t down_thread; // VSwitch → TAP
```

**Important**: Handle thread synchronization properly
- Use proper cleanup on exit
- Handle signals for graceful shutdown

### Key Data Structures

```c
typedef struct {
  int tapfd;                    // TAP device file descriptor
  int vport_sockfd;             // UDP socket to VSwitch
  struct sockaddr_in vswitch_addr; // VSwitch address
} vport_t;
```

### System Utilities

**Error Handling Pattern** (from `sys_utils.h`):
```c
#define ERROR_PRINT_THEN_EXIT(msg...) \
  fprintf(stderr, ##msg);             \
  exit(1);
```

**TAP Device Creation** (from `tap_utils.h`):
- Use `ioctl` with `TUNSETIFF`
- Set `IFF_TAP | IFF_NO_PI` flags
- Configure interface with `ifconfig` or `ip` commands

---

## Package Management

### Supported Package Managers

1. **Conan**: C++ package manager
   ```bash
   cmake -B build -DProject_ENABLE_CONAN=1
   ```

2. **Vcpkg**: Microsoft's C++ package manager
   ```bash
   cmake -B build -DProject_ENABLE_VCPKG=1
   ```

### Adding Dependencies

1. Update `cmake/Conan.cmake` or `cmake/Vcpkg.cmake`
2. Add to `find_package()` in `CMakeLists.txt`
3. Link with `target_link_libraries()`

---

## Common Commands

### Building

```bash
# Standard build
mkdir build && cd build
cmake .. -DCMAKE_BUILD_TYPE=Release
cmake --build .

# Build with all features
cmake -B build \
  -DCMAKE_BUILD_TYPE=Release \
  -DProject_ENABLE_UNIT_TESTING=1 \
  -DProject_ENABLE_CLANG_TIDY=1 \
  -DProject_ENABLE_CODE_COVERAGE=1 \
  -DProject_ENABLE_DOXYGEN=1

# Build and install
cmake --build build --target install --config Release
```

### Testing

```bash
# Run all tests
cd build && ctest -C Release -VV

# Run specific test
./build/bin/Release/tmp_test_Tests

# With Makefile
make test
make coverage
```

### Code Quality

```bash
# Format code
cmake --build build --target clang-format
# or
make format

# Generate documentation
make docs
```

### Cleaning

```bash
# Remove build directory
rm -rf build/

# Clean and rebuild
make clean && make
```

---

## Performance Optimization

### Compiler Optimizations

1. **Link Time Optimization (LTO)**:
   ```bash
   cmake -B build -DProject_ENABLE_LTO=1
   ```

2. **Ccache**: Enabled by default for faster rebuilds
   ```bash
   cmake -B build -DProject_ENABLE_CCACHE=1
   ```

3. **Build Types**:
   - `Debug`: No optimization, debug symbols
   - `Release`: Full optimization (-O3)
   - `RelWithDebInfo`: Optimization + debug symbols
   - `MinSizeRel`: Optimize for size

### Profiling & Debugging

1. **Address Sanitizer** (ASan):
   ```bash
   cmake -B build -DProject_ENABLE_ASAN=1
   ```
   Detects: memory leaks, use-after-free, buffer overflows

2. **Valgrind**: For memory debugging
   ```bash
   valgrind --leak-check=full ./build/bin/Debug/program
   ```

3. **GDB**: For debugging
   ```bash
   gdb ./build/bin/Debug/program
   ```

---

## Common Patterns & Idioms

### RAII (Resource Acquisition Is Initialization)

Always use RAII for resource management:
```cpp
class FileHandler
{
public:
  FileHandler(const std::string& filename)
  {
    file_ = fopen(filename.c_str(), "r");
    if (!file_) throw std::runtime_error("Cannot open file");
  }
  
  ~FileHandler()
  {
    if (file_) fclose(file_);
  }
  
  // Delete copy, allow move
  FileHandler(const FileHandler&) = delete;
  FileHandler& operator=(const FileHandler&) = delete;
  FileHandler(FileHandler&&) = default;
  FileHandler& operator=(FileHandler&&) = default;

private:
  FILE* file_;
};
```

### Rule of Five

If you define any of these, define all:
1. Destructor
2. Copy constructor
3. Copy assignment operator
4. Move constructor
5. Move assignment operator

Or explicitly delete them:
```cpp
MyClass(const MyClass&) = delete;
MyClass& operator=(const MyClass&) = delete;
```

### Header-Only Libraries

For header-only libraries:
```cmake
option(${PROJECT_NAME}_BUILD_HEADERS_ONLY "Build as header-only" OFF)

if(${PROJECT_NAME}_BUILD_HEADERS_ONLY)
  add_library(${PROJECT_NAME} INTERFACE)
  target_compile_features(${PROJECT_NAME} INTERFACE cxx_std_17)
endif()
```

---

## Troubleshooting

### Common Build Issues

1. **In-source build error**: Always build in separate `build/` directory
2. **Missing dependencies**: Install via package manager (Conan/Vcpkg)
3. **Compiler version**: Ensure C++17 support (GCC 7+, Clang 5+, MSVC 2017+)
4. **CMake version**: Update to 3.15 or higher

### Performance Issues

1. Enable compiler optimizations (`-DCMAKE_BUILD_TYPE=Release`)
2. Use ccache for faster rebuilds
3. Enable LTO for better optimization
4. Profile with appropriate tools

---

## Additional Resources

- [C++ Core Guidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines)
- [Modern CMake](https://cliutils.gitlab.io/modern-cmake/)
- [GoogleTest Documentation](https://google.github.io/googletest/)
- [Clang-Format Options](https://clang.llvm.org/docs/ClangFormatStyleOptions.html)

---

## When Using AI (Cursor) Assistance

### Code Generation Guidelines

1. **Always follow project structure**: Place headers in `include/`, sources in `src/`
2. **Match existing style**: Use clang-format configuration
3. **Include tests**: Generate corresponding test file for new modules
4. **Update CMake**: Add new files to `cmake/SourcesAndHeaders.cmake`
5. **Document code**: Include Doxygen comments for public APIs
6. **Follow C++17**: Use modern C++ features appropriately
7. **Error handling**: Use exceptions for C++, error codes for C
8. **Thread safety**: Document thread safety requirements
9. **Namespace**: Always wrap code in appropriate namespace

### Questions to Ask AI

- "Generate a new module following the project structure"
- "Add comprehensive tests for this function"
- "Update CMakeLists.txt to include new source files"
- "Format this code according to project .clang-format"
- "Add Doxygen documentation for this API"
- "Create architecture diagram in Mermaid format"
- "Implement RAII wrapper for this resource"
- "Add error handling following project conventions"

### What AI Should Know

- This is a **C++17** project with modern CMake (3.15+)
- Code style is **Google-based with Allman braces**
- Testing uses **GoogleTest**
- Documentation uses **Doxygen + Mermaid**
- Project structure is **modular** with clear separation
- Both **C and C++** code exist (C for VPort, C++ for modern components)
- Networking code operates at **Layer 2 (Ethernet)**

---

*Last Updated: 2025-10-26*
*This document should be kept up-to-date as project conventions evolve.*

